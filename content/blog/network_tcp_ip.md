+++
title = "TCP/IP"
date = "2025-07-13T22:00:43+08:00"

#
# description is optional
#
# description = "An optional description for SEO. If not provided, an automatically created summary will be used."

tags = ["github","hugo","os",]
+++

## TCP，UDP

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。
- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

TCP四元组：源地址，源端口，目标地址，目标端口

TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。
UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。

TCP三次握手的目的：
同步初始序列号
验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收
防止已失效的连接请求突然传到服务器
为什么不能是两次握手：
单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文
序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。
防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN+ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN+ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。

每次TCP连接建立时，初始化的序列号要求都不一样。

Q：为什么 TIME_WAIT 等待的时间是 2MSL？
A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。

TCP重传、滑动窗口、流量控制、拥塞控制

TCP重传
- 超时重传：超过RTO后重传（RTO应该略大于往返时延RTT）
- 快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK）
- SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。
- D-SACK：使用SACK告诉发送方哪些数据被重复**接收**，可以判断ACK丢包和网络延时。

滑动窗口：

TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有**累计应答**机制，即收到了ACK10，表示seq10之前的数据全都被收到了。

窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。

流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。

（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）

拥塞控制
- 慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小+1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1->2->4->8）。到达慢启动门限后使用拥塞避免算法。
- 拥塞避免
- 拥塞发生
- 快速恢复